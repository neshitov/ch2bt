LoadPackage("Gauss");

Read("SparseReduction.gap");
carat_folder := "/home/alexander/ch2bt/carat_tables";
files := [
  Concatenation(carat_folder, "/cryst1.txt"),
  Concatenation(carat_folder, "/cryst2.txt"),
  Concatenation(carat_folder, "/cryst3.txt"),
  Concatenation(carat_folder, "/cryst4.txt"),
  Concatenation(carat_folder, "/cryst5.txt"),
  Concatenation(carat_folder, "/cryst6.txt"),
  "/home/alexander/ch2bt/FlabbyResolution.gap"
];


for file in files do
  Read(file);
od;
cryst := [cryst1, cryst2, cryst3, cryst4, cryst5, cryst6];


Carat := function(d, n, i)
  return cryst[d][n][i];
end;


Dual := function(mat_gens)
  # Return dual lattice to the lattice with action of group generated by mat_gens.
  local result, m;
  for m in mat_gens do
    Add(result, TransposedMat(Inverse(m)));
  od;
  return result;
end;


Mod2FastInverse := function(m)
  # Return inverse of a finite order matrix
  local inverse, count;
  count := 0;
  inverse := Z(2) * IdentityMat(DimensionsMat(m)[1]);
  while (inverse * m <> Z(2) * IdentityMat(DimensionsMat(m)[1])) or (count > 100) do
    inverse := inverse * m;
    count := count + 1;
  od;
  if inverse * m <> Z(2) * IdentityMat(DimensionsMat(m)[1]) then
    Error("Fast inverse fail");
  fi;
  return inverse;
end;


Mod2Image := function(m)
  # Return the image of the matrix map m
  local pivots;
  pivots := PositionsProperty(EchelonMat(m).heads, i-> i>0);
  return m{[1..DimensionsMat(m)[1]]}{pivots};
end;

LeftInverse := function(m)
  # Return a matrix a such that a*m = I if such a exists
  local emt, inv;
  emt := EchelonMatTransformation(m);
  inv := TransposedMat(emt.vectors) * emt.coeffs;
  if inv * m <> Z(2) * IdentityMat(DimensionsMat(m)[2]) then
    Error("Left inverse failure");
  fi;
  return inv;
end;


FlasqueResolution := function(g)
  # Flasque resolution (all matrices act on the left)
  local fr;
  fr:= FlabbyResolution(TransposedMatrixGroup(g));
  return rec(injection:=TransposedMat(fr.injection),
             surjection:=TransposedMat(fr.surjection),
             actionP:=TransposedMatrixGroup(fr.actionP),
             actionF:=TransposedMatrixGroup(fr.actionF));
end;


CoflasqueResolution := function(gens)
  # Coflasque resolution (all matrices act on the left)
  local d, fr;
  d := DimensionsMat(gens[1])[1];
  fr:= FlabbyResolution(Group(gens, IdentityMat(d)));
  return rec(injection:=fr.surjection,
             surjection:=fr.injection,
             actionP:=GeneratorsOfGroup(fr.actionP),
             actionC:=GeneratorsOfGroup(fr.actionF));
end;


CheckResolution := function(gens, res)
  local diff, i;
  if Length(gens) <> Length(res.actionP) then
    Error("Wrong number of P gens");
  fi;
  if Length(gens) <> Length(res.actionC) then
    Error("Wrong number of C gens");
  fi;
  for i in [1..Length(gens)] do
    diff:= gens[i] * res.surjection - res.surjection * res.actionP[i];
    if diff <> NullMat(DimensionsMat(diff)[1], DimensionsMat(diff)[2]) then
      Error("Projection equivariance Error");
    fi;
  od;
  for i in [1..Length(gens)] do
    diff:= res.actionP[i] * res.injection - res.injection * res.actionC[i];
    if diff <> NullMat(DimensionsMat(diff)[1], DimensionsMat(diff)[2]) then
      Error("Injection equivariance Error");
    fi;
  od;
end;


MatrixRelations := function(m)
  #  Get relations between matrices in the given list.
  local G, rel, rels, result;
  result := [];
  G := Group(m);
  G := Image(IsomorphismFpGroupByGenerators(G, m));
  rels := RelatorsOfFpGroup(G);
  for rel in rels do
    Add(result, TietzeWordAbstractWord(rel));
  od;
  return result;
end;


CocycleRelation := function(gens, d, w)
  # Create map corresponding to the relation w.
  local n_gens, proj, result, action, proj_w_inverse, i, proj_, action_;
  n_gens := Length(gens);
  action := function(i)
    if i > 0 then
      return gens[i];
    else
      return Mod2FastInverse(gens[-i]);
    fi;
  end;

  proj := function(i)
    local res;
    res := BlockMatrix([[1, i, IdentityMat(d)]], 1, n_gens);
    res := Z(2) * MatrixByBlockMatrix(res);
    return res;
  end;

  proj_w_inverse := function(i)
    if i > 0 then
      return proj(i);
    else
      return - action(i) * proj(-i);
    fi;
  end;

  result := proj_w_inverse( w[Length(w)] );
  for i in Reversed( w{[ 1.. Length(w) - 1 ]} ) do
    proj_ := proj_w_inverse(i);
    action_ := action(i);
    result:= proj_ + action_*result;
  od;
  return result;
end;


CocycleRelations := function(gens, d, relations)
  local cocycle_relations, relation;
  cocycle_relations := [];
  for relation in relations do
    cocycle_relations := Concatenation(cocycle_relations, CocycleRelation(gens, d, relation));
  od;
  return cocycle_relations;
end;


Z1Mod2 := function(gens, relations)
  # Construct the inclusion Z^1(G, M/2) -> M^gens/2
  local c_rel, result, d;
  d := DimensionsMat(gens[1])[1];
  c_rel := CocycleRelations(gens, d, relations);
  result := NullspaceMat(TransposedMat(c_rel));
  return TransposedMat(result);
end;


B1Mod2 := function(gens)
  # Construct the inclusion B^1(G,M/2) -> M^gens/2
  local result, d, b1_incl;
  d := DimensionsMat(gens[1])[1];
  b1_incl := BlockMatrix(List([1..Length(gens)], i -> [i, 1, Z(2) * ( gens[i] - IdentityMat(d) )]),
                         Length(gens), 1); # Inclusion B^1(G,M) -> M^gens
  b1_incl := Mod2Image(b1_incl);
  return b1_incl;
end;


#Testsuka := function(gens)
#  local b, i, d;
#  d := DimensionsMat(gens[1])[1];
#  b := SparseMatrix(gens[1]);
#  for i in [2..Length(gens)] do
#    b := UnionOfRows(b, SparseMatrix(gens[i]));
#  od;
#  return b;
#end;


B1 := function(gens, ring)
  # Constructs the inclusion of B^1(G,M) -> M^gens tensored with ring
  local b, i, d;
  d := DimensionsMat(gens[1])[1];
  b := SparseMatrix((gens[1] - IdentityMat(d)) * One(ring));
  for i in [2..Length(gens)] do
    b := UnionOfRows(b, SparseMatrix((gens[i] - IdentityMat(d)) * One(ring)));
  od;
  return b;
end;


ReduceSparseVectorMod2 := function(indices, entries)
  local new_indices, filter;
  filter := Filtered([ 1 .. Length(indices) ], i -> Int(entries[i]) mod 2 <> 0);
  new_indices := indices{filter};
  return new_indices;
end;


ReduceSparseMatrixMod2 := function(sm)
  # Reduce sparse matrix modulo 2.
  return SparseMatrix( Nrows(sm),
                       Ncols(sm),
                       List( [ 1 .. Nrows(sm) ],
                       i -> ReduceSparseVectorMod2( sm!.indices[i],
                                                    sm!.entries[i] ) ) );
end;


Z1Part := function(gens, group_order)
  # Returns generators of Z1 that do not belong to B1 inside M^gens

  local order, b, tr, non_one_cols, z1_part;

  order := group_order * 2;

  if order <> 2 ^ PValuation(order, 2) then
    Error("Not a 2 group");
  fi;
  b := B1(gens, Integers mod order);
  tr := SNFTransform(b);

  non_one_cols := Filtered( [ 1 .. tr.rank ],
                            i -> tr.SNF!.entries[i][1] <> One( Integers mod order ) );
  z1_part := CertainColumns( tr.row_t_inverse, non_one_cols );
  return ReduceSparseMatrixMod2(z1_part);
end;


ExtSquareIterator :=function(d)
  # iterates over basis of exterior square in order 12 13 .. 1d, 23 24.. 2d,
  local result, i, j;
  result := [];
  for i in [1..d-1] do
    for j in [i+1..d] do
      Add(result, [i, j]);
    od;
  od;
  return result;
end;


ExteriorProduct :=function(u, v)
  local d, product, i, j, mi, pair, iterator;
  d := Length(u);
  product := [];
  iterator := ExtSquareIterator(d);
  for pair in iterator do
    i := pair[1];
    j := pair[2];
    mi := [[u[i], v[i]],
           [u[j], v[j]]];
    Add(product, Determinant(mi));
  od;
  return product;
end;


ExteriorSquare := function(gens)
  local square_gens, square_gen, column, i, j, m, m_columns, d, pair, iterator;
  square_gens := [];
  if Length(gens) > 0 then
    d := DimensionsMat(gens[1])[1];
    iterator := ExtSquareIterator(d);
    for m in gens do
      square_gen := [];
      m_columns := TransposedMat(m);
      for pair in iterator do
        i := pair[1];
        j := pair[2];
        column := ExteriorProduct(m_columns[i], m_columns[j]);
        Add(square_gen, column);
      od;
      square_gen := TransposedMat(square_gen);
      Add(square_gens, square_gen);
    od;
    return square_gens;
  else
    return [];
  fi;
end;


MapK := function(res, num_gens)
  # For a resolution N -> P -> M given by matrix m constructs the matrix of the map
  # Lambda^2 N^gens -> M/2^gens
  local m_columns, dim_N, dim_P, result, column, i, j, k, iterator, pair;
  result := [];
  m_columns := TransposedMat(res.injection);
  dim_P := Length(res.injection);
  dim_N := Length(m_columns);
  iterator := ExtSquareIterator(dim_N);

  for pair in iterator do
    i := pair[1];
    j := pair[2];
    column := [];
    for k in [ 1 .. dim_P ] do
      Add(column, res.injection[k][i] * res.injection[k][j]);
    od;
    Add(result, column);
  od;
  result := TransposedMat(result);
  result := Z(2) * result;
  result := (Z(2) * res.surjection) * result;
  result := BlockMatrix( List( [ 1.. num_gens ], i -> [ i, i, result ] ),
                         num_gens, num_gens ); # L2n^gens -> M/2^gens
  return result;
end;


MatConcat := function(m_list)
  local nrows;
  nrows := DimensionsMat(m_list[1])[1];
  return List([1..nrows], i -> Concatenation(List(m_list, x -> x[i])));
end;


ComputePhi := function(gens, cr)
  local relations, group_order, result, ZP2, ZM2, PM, BM2, _start, _end, L, L2,
        ZL, ZL2, mapk;

  relations := MatrixRelations(gens);
  group_order := Order( Group( gens ) );
  result := rec();

  _start := NanosecondsSinceEpoch();

  ZP2 := Z1Mod2(Z(2) * cr.actionP, relations); # Z^1(P/2) -> P/2^gens
  ZM2 := Z1Mod2(Z(2) * gens, relations); # Z^1(M/2) -> M/2^gens
  PM := BlockMatrix(List([1..Length(gens)], i -> [i, i, Z(2) * cr.surjection]),
                    Length(gens), Length(gens)); # P^gens -> M^gens;

  ZP2 := PM * ZP2; # Z1(P/2) -> M^gens/2
  BM2 := B1Mod2(gens); # B1(M/2) -> M^gens/2

  result.HM2_rank := RankMat( ZM2 ) - RankMat( BM2 );
  result.im_HP2_rank := RankMat( MatConcat( [BM2, ZP2] ) ) - RankMat( BM2 );

  if result.im_HP2_rank = result.HM2_rank then
    result.Phi_rank := 0;
    return result;
  fi;

  _end := NanosecondsSinceEpoch();
  Print("Coflasque resolution rank ");
  Print(DimensionsMat( cr.actionC[1])[1] );
  Print("\n");
  Print("H1P2 done in ");
  Print( Float( (_end - _start) / ( 60 * (10^9) ) ) );
  Print("\n");

  _start := NanosecondsSinceEpoch();

  L := ExteriorSquare(cr.actionC); # Lambda^2(N)
  mapk := MapK(cr, Length(gens)); # L2N^gens -> M^gens/2

  #L2 := Z(2) * L; # Lambda^2(N)/2
  #ZL2 := Z1Mod2( L2, relations );
  #ZL2 := mapk * ZL2;
  #result.im_HL2_rank := RankMat( MatConcat( [BM2, ZL2] ) ) - RankMat(BM2);

  #if result.im_HL2_rank = result.im_HP2_rank then
  #  result.Phi_rank := 0;
  #  #return result;
  #fi;

  #_end := NanosecondsSinceEpoch();
  #Print("H1L2 done in ");
  #Print(Float( (_end - _start) / ( 60 * (10^9) ) ) );
  #Print("\n");
  #_start := NanosecondsSinceEpoch();

  ZL := Z1Part(L, group_order);
  ZL := SparseMatrix( mapk ) * ZL;
  ZL := ConvertSparseMatrixToMatrix( ZL );
  result.im_HL_rank := RankMat( MatConcat( [BM2, ZL] ) ) - RankMat(BM2);
  result.Phi_rank := RankMat( MatConcat( [BM2, ZL, ZP2] ) ) - RankMat( MatConcat( [BM2, ZP2] ) );

  _end := NanosecondsSinceEpoch();
  Print("H1L done in ");
  Print(Float( (_end - _start) / ( 60 * (10^9) ) ) );
  Print("\n");

  return result;

end;
