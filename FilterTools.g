####################################################################
# Code to filter out subgroups that are either
#  *decomposable
#  *Sign permutations
#  *Not a 2 group of order > 4
#####################################################################

IsDecomposable:= function(n, matrix_list)
  # Construct equivalence relation on {1..n} generated by R:
  # (i,j) in R <=> m[i,j]<>0 for some m in matrix_list where all m are of size nxn
  # Determine if all elements are equivalent.
  local domain, r, er, partition, i, j, m;
  domain := Domain([1..n]);
  r := [];
  for m in matrix_list do
    for i in domain do
      for j in domain do
        if m[i][j]<>0 then
          Add(r, Tuple([i,j]));
        fi;
      od;
    od;
  od;
  #Print("r=");
  #Print(r);
  r:= BinaryRelationByElements(domain, r);
  er := EquivalenceRelationByRelation(r);
  partition := EquivalenceRelationPartition(er);
  if Length(partition) > 0 then
    if (Length(partition[1]) = n) then
      return false;
    fi;
  fi;
  return true;
end;


IsSignPermutationRow:= function(row)
  local has_one, entry;
  has_one := false;
  for entry in row do
    if entry <> 0 then
      if AbsInt(entry) > 1 or has_one then
        return false;
      else
        has_one := true;
      fi;
    fi;
  od;
  return true;
end;


IsSignPermutationMatrix:= function(m)
  # Check if m is a signed permutation under the assumption that m is invertible.
  local row;
  for row in m do
    if not IsSignPermutationRow(row) then
      return false;
    fi;
  od;
  return true;
end;


IsSignPermutationList:= function(matrix_list)
  # Check if list of invertible matrices conists of sign permutations.
  local m;
  for m in matrix_list do
    if not IsSignPermutationMatrix(m) then
      return false;
    fi;
  od;
  return true;
end;


IsTwoPrimary:= function(x)
  # Check if a number is a power of 2
  local n;
  n := x;
  while (RemInt(n, 2) = 0) and (n > 1) do
    n := QuoInt(n, 2);
  od;
  return n = 1;
end;


IsTwoGroup_greater_4:= function(matrix_list)
  # Check if list of matrices generates a 2-group of order > 4
  local order;
  order := Order(Group(matrix_list));
  return (IsTwoPrimary(order) and (order > 4));
end;


KeepGroup:= function(n, matrix_list)
  if IsSignPermutationList(matrix_list) then
    return false;
  elif IsDecomposable(n, matrix_list) then
    return false;
  elif not IsTwoGroup_greater_4(matrix_list) then
    return false;
  else
    return true;
  fi;
end;
